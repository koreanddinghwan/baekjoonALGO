스터디 준비


클래스에서 알아야하는것.

# 클래스란
객체를 찍어내기 위한 문법이다.
이 객체는 클래스와 함께 말할때는 인스턴스라고 부른다.

```python
class person:
    def sayhello(self):
        print('sayhello')

james = person()
```

person은 클래스이며 james는 person의 인스턴스이다.
james는 객체이다.
복잡한 문제를 잘게 나누어 객체로 만들고, 객체를 조합해 문제를 해결하는 것을  객체지향 프로그래밍이라고한다.


# 인스턴스 속성
인스턴스 속성은 self.으로 붙여서 호출하는 속성을 의미한다.  
```python
class time:
    def from_time(self):
        self.hour

now = time()
hour = now.hour
```
now 라는 객체를 만들어냈는데, time이라는 클래스로 만들었다. 
now는 time의 인스턴스이다.
hour는 self.를 앞에 붙이므로 인스턴스의 속성, 인스턴스 속성이 된다.

## 셀프
셀프는 인스턴스 자기자신을 의미한다.  
인스턴스로 a라는 객체가 만들어지면, a라는 객체의 인스턴스 속성에 접근할 수 있게된다.


# 클래스 속성
반면 클래스 속성은 클래스 전체에서 호출할 수 있는 속성이다.
```python
class bag:
    bag = []
    def asdf(self):
        self.asdf
```
클래스 속성은 bag이다. 이 클래스 속성에 접근하는 절차는 인스턴스->클래스이다.  
앞서 말했듯 우리는 인스턴스가 가진 속성을 인스턴스 속성이라 불렀고, 우리는 인스턴스 속성을 불러오기위해서
인스턴스이름.속성이름 으로 불렀다.  
클래스 속성도 똑같이 인스턴스이름.속성이름 으로 부를 수 있는데,  
클래스이름.속성이름 으로도 클래스 속성을 불러올 수 있다.  
왜냐하면 파이썬은 속성을 불러올때 2가지 절차를 거치는데, 1번째로 해당 속성이름이 인스턴스에 있는지, 그리고 2번째로 클래스에 있는지를 확인한다.

만약 인스턴스.속성이름 으로 불렀는데 클래스 속성이 호출된거라면 1번과정을 거쳤는데 인스턴스에 속성이름이 존재하지 않아 2번단계를 거쳐 클래스 속성을 받아온것이라고
생각하면 된다. 


# 인스턴스 메서드
메서드에 대해서 공부했다.  


# 클래스 메서드
정적메서드


# 모듈
관련이 있는, 변수 클래스 함수등 파이썬 구성요소를 모아놓은 파일이다.  
작성 중인 파일에서 다른 파일의 어떠한 변수, 클래스, 함수들을 가져올 수 있다.  

sys, math, random 등의 모듈들은 빌트인 모듈로 파이썬에서 기본적으로 제공하는 모듈들이다.  
그래서 print(sys.path)를 해보면 파이썬이 설치된 파일 안에 모듈이 들어와 있는 것을 알 수 있다.  
이런 모듈의 경로를 따라 우리가 파일 안에서 import했을때, 모듈이 들어와지는 것이다. 

모듈이 모이면 패키지가된다.  




## 같은 경로의 모듈을 import하는 방법
현재 파일의 폴더의 경로나, 하위경로에 import하고자하는 파일이 존재한다면,  
import 파일명.파일명.. 이렇게 import가 쉽게 된다.

파이썬은 패키지로 분할된 개별적인 모듈로 구성된다.  
기본적으로 알아야하는 것은 상대경로에 접근하기위해서는 
`../`로 부모디렉터리에, `./`로 현재 디렉터리의 주소를 생략해서 작성할 수 있다는 것이다.  

이렇게 모듈을 import하는 방법에는 여러가지가 있는데, 
1. 단순히 import a.b.c로 import
2. from a.b import c
3. from a.b import * #모든 모듈 import
4. from a.b import c as d #d라는 별칭으로 import




## 다른 경로의 모듈을 import하는 방법
모듈의 path는 리스트로 만들어져있다.
sys.path를 해보면 sys모듈의 경론가 주루룩 나오는데, 해당 경로로 우리는 모듈을 추가할 수 있다.  
sys.path는 리스트로 이루어져있으므로, sys.path.append 메서드로 모듈의 파일주소를 추가해주면된다.  
만약 mymodules폴더 안에 내 모듈이 들어가 있다면  
sys.path에 '/Users/ddinghwan/mymodules'을 추가하면 된다.  
그리고 `import 모듈명`으로 모듈주소를 추가해주면 이제 우리는 이 파일 안에 있는 모듈들을 사용할 수 있게 된다!  

다만, 파일을 새로 작성할때마다, 우리는 계속 이 주소를 sys.path에 추가해줘야한다는 단점이있다.  

이런 단점을 보완하기 위해서는 python path에 영구적으로 모듈위치를 등록해야하는데, 모듈 이름을 잘 못 지었다가는 영원히....다른 모듈 못 사용할수도있다.  
리스트의 특성상, 파일을 찾으면 그 뒤로는 검색하지 않기때문이다.  

가장 간단한 방법으로는 그냥 a라는 모듈을 기존 python path폴더에 넣는 방법이 있다. 

## __name__ 내장변수 사용
자 그럼 모듈을 import했을때, 모듈 내의 있는 함수, 변수, 클래스등을 제외한  
명령어들을 불러오지않기위해서는 어떻게해야할까?

파이썬은 모듈이 실행되는 위치를 `__name__` 내장변수를 이용해 구분한다.

모듈파일에
```python
if __name__ == "__main__":
    명령어들
```
`__name__`은 현재 모듈의 이름을 담고있는 내장변수이다. 
직접 실행된 모듈의 경우(모듈파일 자체에서 실행된경우)-> __main__이라는 값을 가지게되며
명령어들이 실행되는 반면에,  
다른 파일에서 직접실행되지 않은 import된 모듈은  
모듈의 `__name__`이 모듈의 모듈이름을 가지게된다.  

이렇게 모듈안에 명령어들이 들어가있으면 이 명령어들은
파일을 실행하는 위치가 나 자신이 아니라면 실행되지 않는다!  
모듈을 만들때, 테스트코드를 위 조건문 아래에 위치시키면 효율적으로 프로그래밍을 할 수 있다.  







inspect 모듈은 현재 파일의 경로를  표시해줄 수 있다. 
inspect.getfile(inpect.currentframe()) 으로 현재 파일 경로를 문자열로 리턴하는 메서드를 호출할 수 있다.  




각 패키지마다 있는 __init__은 파이썬에게 패키지 안의 모듈이 import가능한 패키지라는 것을 인식시켜준다.  
단, 파이썬3.3부터는 없어도 패키지로 인식된다.  
하위호환을 위해서 작성하는 것을 추천한다.
__all__ = ['모듈명'] 으로 선언되어있는데, 리스트 안에 import가 가능한 모듈들의 파일명들을 넣어야한다. 
비워놓으면 패키지 내의 모든 모듈을 import가능하게끔한다.




# 예외처리

의도대로 프로그램이 작동하지 않으면 , 비정상적으로 발생한 오류
예측이 가능한 오류


 systaxerror : 문법오류
print('a)
 print('a'))
 if True;

 typeerror : 다른 자료형끼리 연산하거나, 알맞지않은 자료형을 메서드에 쓸때 
 a = [1,2,3]
 print(a['1'])

 nameerror : 참조 불가능한 변수
 a = 10
 b = 15
 print(c)

 zerodivisionerror : 0으로 나누는 경우
 print(100/0)



 indexerror : 인덱스 범위밖의 인덱스를 불러올때
 x = [50,70,90]
 print(x[4])


 valueerror : 참조 불가능한 값
 x = [10,50,90]
 x.remove(100)


 attribute error : 모듈, 클래스의 잘못된 속성사용
 import time
 print(time.time2())



 keyerror
 dic = {'name' : 'kang', 'age' : 21}
 print(dic['age'])
  print(dic['from'])
 print(dic.get('from'))

 filenotfounderror
 f = open('text.txt')


 문법적으로는 예외가 없지만, 코드 실행단계에서 발생하는 예외
 예외는 반드시 처리해야한다.
 로그는 반드시 남긴다. 어떤 예외가 발생했었는지 기록으로 남겨야한다.
 예외는 던져진다.,,다른곳으로 처리위임이 가능하다
 예외의 무시처리가 가능하다.


 예외처리 기본
try: 에러가 발생할 가능성이 있는 코드 실행
 except 에러명1: 에러발생시 실행할 코드
 except 에러명2:
 else: try 블록의 에러가 없으면 실행되는 코드(for-else문과 비슷)
 finally: 항상 마지막에 실행된다.

 name = ['kim','lee','park']
 1
 try:
     z = 'asd'
     x = name.index(z)
     print('found!', x + 1)
 except ValueError:
     print('notfound, valueerror')
 else:
     print('ok')
     print()

except Exception 을 하게되면 모든 종류의 에러를 잡아준다. 또는 except: 도 동일한 역할을 한다.
특히 except Exception을 사용할때 as e 로 별칭을 붙이면 이 e가 에러의 내용을 담아 print(e)를 해보면 에러의 내용을 알 수 있다.



raise
 raise 키워드로 예외를 직접 발생시킬수도 있다. 
 보통은 try에서 raise로 에러를 던진다음에
 except로 해당 에러를 잡아내는  방식이다.

per = ["10.31", "", "8.00"]
new_per = []

for i in per:
    try:
        v = float(i)
    except:
        v = 0
    new_per.append(v)

print(new_per)
